\section{Wprowadzenie do programowania w~języku C}

\subsection{Wstęp}
Treść laboratorium zawiera krótkie wprowadzenie do języka programowania C jako tego, który będzie wiodący w dalszych etapach zajęć. Wprowadzenie to pozwoli zacząć programować w języku C, tak szybko, jak to możliwe. Nie należy jednak traktować tej części laboratorium, jako substytutu kursów języka C, prezentowanych na innych wykładach i laboratoriach oraz w podręcznikach poświęconych językowi C. Pozostałe podrozdziały omawiają również podstawy użytkowania kompilatora oraz narzędzi make obecnych w~systemie QNX.

\subsection{Kompilowanie i~uruchamianie programów}

\subsubsection{Kompilator qcc}

Kody źródłowe, napisane w języku C muszą zostać wstępnie przetworzone (preprocessing), skompilowane (compiling) i skonsolidowane (linking), aby utworzyć plik wykonywalny. Używając linii poleceń, napisany program można skompilować w systemie QNX za pomocą następujących komend:


Dla języka C:

\begin{lstlisting}[style=MyBashStyle]
qcc [opcje] [operandy]
\end{lstlisting}

Dla języka C++:

\begin{lstlisting}[style=MyBashStyle]
QCC [opcje] [operandy]
\end{lstlisting}

Wybrane opcje kompilatora qcc zestawiono w~tabeli~, natomiast operandy stanowią pliki źródłowe (\lstinline[style=MyBashStyle]{*.c}) oraz pliki typu (\lstinline[style=MyBashStyle]{*.o}).

\begin{table}[h!]
\centering
\caption{Wybrane opcje kompilatora \lstinline[style=MyBashStyle]{qcc}}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.20\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Opcje} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-c}} & Tylko kompilacja \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-E}} & Preprocessing na standardowe wyjście \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-g}} & Kompilacja z debugowaniem \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-I path [:path ...]}} & Ustawia ścieżkę przeszukiwania dla dyrektyw \mbox{\lstinline[style=MyBashStyle]{#include}}  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-L path [:path ...]}} & Ustawia ścieżkę przeszukiwania dla bibliotek  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-lplik}} & Dołącza bibliotekę o nazwie lib\underline{plik}.a lub lib\underline{plik}.so.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-O1}} & Kompilowanie z optymalizacją \mbox{\lstinline[style=MyBashStyle]{O1}}.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-O2}} & Kompilowanie z optymalizacją \mbox{\lstinline[style=MyBashStyle]{O2}}.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-O3}} & Kompilowanie z optymalizacją \mbox{\lstinline[style=MyBashStyle]{O3}}.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-o outfile}} & Ustala nazwę pliku wyjściowego (wykonywalnego). Domyślnie \mbox{\lstinline[style=MyBashStyle]{a.out}}.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-Wall}} & Wyświetla wszystkie ostrzeżenia kompilatora.  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{-pedantic}} & Wyświetla wszystkie ostrzeżenia kompilatora wymagane przez ANSI C.  \\ \hline
\end{tabular}
\label{tab:opcjeqcc}
\end{table}


\begin{example}[Konfiguracja środowiska pracy]
W~trakcie tego laboratorium będziemy głównie pracować w~linii poleceń. Zanim przejdziemy do właściwych przykładów, musimy skonfigurować środowisko pracy.

\begin{myenumerate}
\item  Ustawiamy zmienne środowiskowe w~systemie Windows. W tym celu należy:
\begin{myitemize}
\item Otworzyć linię poleceń w~systemie Windows, tj. nacisnąć przycisk \lstinline[style=MyBashStyle]{Start}, a~w~okienku \lstinline[style=MyBashStyle]{Wyszukaj programy i pliki} wpisać nazwę \lstinline[style=MyBashStyle]{cmd}.
\item W linii poleceń, uruchomić skrypt \lstinline[style=MyBashStyle]{C:\qnx660\qnx660-env.bat}.
\end{myitemize}

\item Na pulpicie tworzymy katalog o~nazwie \lstinline[style=MyBashStyle]{tmp}.
\item W~linii poleceń przechodzimy do katalogu \lstinline[style=MyBashStyle]{tmp} wpisując komendę \lstinline[style=MyBashStyle]{cd C:\Users\prog_N\Desktop\tmp}, gdzie \lstinline[style=MyBashStyle]{N} jest numerem komputera, do którego zalogowany jest użytkownik.
\item Uruchamiamy maszynę wirtualną z~systemem operacyjnym QNX oraz sprawdzamy IP maszyny za pomocą polecenia \lstinline[style=MyBashStyle]{ifconfig}.
\item Uruchamiamy środowisko do programowania aplikacji QNX Momentics oraz konfigurujemy dostęp do platformy docelowej w~kartach \lstinline[style=MyBashStyle]{Target Navigator} oraz \lstinline[style=MyBashStyle]{Target File System Navigator}.
\end{myenumerate}
\end{example}

\begin{example}[Pierwszy program...] \label{ex:pierwszy}

Otworzyć edytor tekstu \lstinline[style=MyBashStyle]{Notatnik}. Wpisać treść poniższego kodu i~zapisać plik pod nazwą \lstinline[style=MyBashStyle]{hello.c} w~katalogu \lstinline[style=MyBashStyle]{tmp} na \lstinline[style=MyBashStyle]{Pulpicie}.

\lstinputlisting[caption=Pierwszy program...,style=MyCStyle,label=src:kod3]{src/lab3/hello.c}

W~linii poleceń (Windows) skompilować program \lstinline[style=MyBashStyle]{hello.c} wydając polecenie:

\begin{lstlisting}[style=MyBashStyle]
> qcc -Wall hello.c
> ls
...
\end{lstlisting}

Proces tworzenia pliku wykonywalnego z~nadaniem nazw plików wyjściowych można podzielić na dwa etapy: kompilacja i~budowanie.

\begin{lstlisting}[style=MyBashStyle]
> qcc -Wall -c hello.c
> qcc hello.o -o hello
> ls
...
\end{lstlisting}

Kod źródłowy \lstinline[style=MyBashStyle]{hello.c} możemy jednocześnie skompilować i~zbudować z~nadaniem nazwy plikowi wyjściowemu.

\begin{lstlisting}[style=MyBashStyle]
> qcc -Wall hello.c -o hello2
> ls
...
\end{lstlisting}

Ostatnim etapem tego przykładu będzie uruchomienie programu \lstinline[style=MyBashStyle]{hello} na maszynie z~systemem operacyjnym QNX. Poprzez widok \lstinline[style=MyBashStyle]{Target File System Navigator} w środowisku QNX Momentics przekopiować program wykonywalny \lstinline[style=MyBashStyle]{hello} z~katalogu \lstinline[style=MyBashStyle]{tmp} do katalogu \lstinline[style=MyBashStyle]{/home} na maszynie wirtualnej. Uruchomić program poprzez polecenie:

\begin{lstlisting}[style=MyBashStyle]
# ./hello

Hello world !!!

#
\end{lstlisting}
\end{example}

\subsubsection{Sterowanie procesem budowania programów}

Kompilacja i uruchamianie projektu, składającego się z wielu plików źródłowych, w których zależności są złożone, może być uciążliwa. Istnieją programy narzędziowe, które ułatwiają zarządzanie złożonymi programami. Jednym z nich jest narzędzie \lstinline[style=MyBashStyle]{make}, które przetwarza specjalny plik \lstinline[style=MyBashStyle]{Makefile}.

W pliku \lstinline[style=MyBashStyle]{Makefile} występują tzw. reguły (ang. rules) mające następującą formę:

\begin{lstlisting}[style=MyBashStyle]
target: prerequisite [prerequisites]
<tab> commands
\end{lstlisting}

Cel (ang. target) - jest zazwyczaj plikiem, który chcemy utworzyć. Zależność (ang. prerequisite) - do utworzenia celu wymagane są zazwyczaj pliki źródłowe; nazywamy je zależnościami. Polecenia (ang. commands) - są krokami (np. wywołania kompilatora lub polecenia powłoki), które należy wykonać, aby utworzyć cel.

\begin{example}[Pierwszy plik Makefile]
W~Notatniku napisać skrypt \lstinline[style=MyBashStyle]{Makefile} do uruchomienia programu zapisanego w~\lstinline[style=MyBashStyle]{hello.c} oraz zapisać go w~katalogu \lstinline[style=MyBashStyle]{tmp}.

\begin{lstlisting}[style=MyBashStyle,caption=Pierwszy plik Makefile]
all: hello
hello: hello.o
	@echo "buduje..."
	qcc hello.o –o hello
hello.o: hello.c
	@echo "kompiluje..."
	qcc –Wall -c hello.c
clean:
	@echo "usuwam..."
	rm -f hello hello.o
\end{lstlisting}

Wpisać w~wiersz poleceń (Windows) następujące wywołania:

\begin{lstlisting}[style=MyBashStyle,caption=Pierwszy plik Makefile]
> make -n
> make all
> ls
...
> make clean
> ls
...
\end{lstlisting}

\end{example}


\begin{example}[Rozbudowany plik Makefile] \label{ex:rozbudowany}
W bardziej rozbudowanych projektach stosuje się różnego typu zmienne, które ułatwiają proces konstrukcji pliku \lstinline[style=MyBashStyle]{Makefile}. Należą do nich zmienne definiowane przez użytkownika, zmienne standardowe (predefiniowane), np. dotyczące nazw kompilatorów i~flag wywołań oraz zmienne automatyczne, których wartości są obliczane, gdy reguła jest wykonywana. Wybrane zmienne standardowe i~automatyczne przedstawiono w tabelach~\ref{tab:zmiennestandardowe} oraz \ref{tab:zmienneautomatyczne}.

\begin{table}[h!]
\centering
\caption{Zmienne standardowe}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.15\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Argumenty} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{CC}} & Nazwa kompilatora języka C \\ \hline
\mbox{\lstinline[style=MyBashStyle]{CXX}} & Nazwa kompilatora języka C++ \\ \hline
\mbox{\lstinline[style=MyBashStyle]{CFLAGS}} & Opcje kompilatora języka C \\ \hline
\mbox{\lstinline[style=MyBashStyle]{CXXFLAGS}} & Opcje kompilatora języka C++  \\ \hline
\mbox{\lstinline[style=MyBashStyle]{LFLAGS}} & Opcje dla linkera  \\ \hline
\end{tabular}
\label{tab:zmiennestandardowe}
\end{table}


\begin{table}[h!]
\centering
\caption{Zmienne automatyczne}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.15\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Argumenty} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{<}} & Nazwa pliku pierwszej zależności \\ \hline
\mbox{\lstinline[style=MyBashStyle]{@}} & Nazwa pliku docelowego \\ \hline
\mbox{\lstinline[style=MyBashStyle]{^}} & Lista wszystkich zależności \\ \hline
\end{tabular}
\label{tab:zmienneautomatyczne}
\end{table}

Zapisać w~Notatniku i uruchomić skrypt \lstinline[style=MyBashStyle]{Makefile} ze zmiennymi standardowymi i automatycznymi.


\begin{lstlisting}[style=MyBashStyle,caption=Rozbudowany plik Makefile]
CC=qcc
CFLAGS=-Wall
LFLAGS=-lm
SRC=hello.c
OBJS=hello.o
BINS=hello

all: $(BINS)
$(BINS): $(OBJS)
	@echo "buduje..."
	$(CC) $(LFLAGS) $^ -o $@
$(OBJS): $(SRC)
	@echo "kompiluje..."
	$(CC) $(CFLAGS) -c $< -o $@
clean:
	@echo "usuwam..."
	rm -f $(OBJS) $(BINS)
.PHONY: all clean
\end{lstlisting}
W przykładzie zastosowano zmienne definiowane przez użytkownika, zmienne standardowe oraz zmienne automatyczne. Dodatkowo użyto reguły \lstinline[style=MyBashStyle]{.PHONY}, służącej do poinstruowania narzędzia \lstinline[style=MyBashStyle]{make}, że reguły \lstinline[style=MyBashStyle]{all} oraz \lstinline[style=MyBashStyle]{clean} są regułami specjalnymi, a nie nazwami plików.
\end{example}


\begin{example}[Makefile w środowisku QNX Momentics]
Możemy wykorzystać plik \lstinline[style=MyBashStyle]{Makefile} utworzony w~przykładzie \ref{ex:rozbudowany} oraz kod źródłowy~\ref{src:kod3} zapisany w~przykładzie~\ref{ex:pierwszy} w~środowisku QNX Momentics. W~tym celu należy:

\begin{myenumerate}
\item W środowisku QNX Momentics utworzyć pusty projekt \lstinline[style=MyBashStyle]{C Project}, który należy nazwać jako \lstinline[style=MyBashStyle]{hello}.
\item Jako typ projektu wybrać \lstinline[style=MyBashStyle]{Empty project}, a~jako kompilator \lstinline[style=MyBashStyle]{QNX QCC}.
\item Zbudować projekt klikając prawym przyciskiem na projekt i~wciskając opcję \lstinline[style=MyBashStyle]{Build Project}.
\item Skonfigurować środowisko do uruchamiania programu i~uruchomić zbudowany program na maszynie QNX.
\item Usunąć pliki tymczasowe z~projektu klikając prawym przyciskiem na projekt i~wciskając opcję \lstinline[style=MyBashStyle]{Clean Project}.
\end{myenumerate}



\end{example}

\subsection{Podstawy języka C}

\subsubsection{Typy zmiennych}

Niektóre wbudowane typy zmiennych przedstawiono w~tabeli~\ref{tab:typyzmiennych}.

\begin{table}[h!]
\centering
\caption{Typy zmiennych}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.1\textwidth}|p{0.45\textwidth}|}
\hline \rowcolor{gray}
\textbf{Typ} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{int}} & integer \\ \hline
\mbox{\lstinline[style=MyBashStyle]{short}} & short integer \\ \hline
\mbox{\lstinline[style=MyBashStyle]{long}} & long integer \\ \hline
\mbox{\lstinline[style=MyBashStyle]{float}} & single precision real (floating point) variable \\ \hline
\mbox{\lstinline[style=MyBashStyle]{double}} & double precision real (floating point) variable \\ \hline
\mbox{\lstinline[style=MyBashStyle]{char}} & character variable (single byte) \\ \hline
\end{tabular}
\label{tab:typyzmiennych}
\end{table}

\subsubsection{Pętle}

Większość programów zawiera pętle, umożliwiające powtarzanie określonych czynności. W języku C istnieje kilka różnych sposobów tworzenia pętli. Dwie najbardziej rozpowszechnione to pętla \lstinline[style=MyCStyle]{while} i~\lstinline[style=MyCStyle]{for}. Składnia poleceń podana jest poniżej.


\begin{lstlisting}[style=MyCStyle]
while (expression)
{
...block of statements to execute...
}
\end{lstlisting}

\begin{lstlisting}[style=MyCStyle]
for (expression_1; expression_2; expression_3)
{
...block of statements to execute...
}
\end{lstlisting}

Pętla \lstinline[style=MyCStyle]{while} jest kontynuowana dopóki wyrażenie logiczne jest prawdą, przy czym warunek ten jest sprawdzany po wejściu do pętli. Pętla \lstinline[style=MyCStyle]{for} jest równoważna następującej pętli \lstinline[style=MyCStyle]{while}.

\begin{lstlisting}[style=MyCStyle]
expression_1;
while (expression_2)
{
...block of statements...
expression_3;
}
\end{lstlisting}

Przykłady zastosowania pętli.

\begin{myitemize}
\item Pętla \lstinline[style=MyCStyle]{while}.
\end{myitemize}

\begin{lstlisting}[style=MyCStyle]
i = initial_i;

while (i < i_max)
{
...block of statements...
i = i + i_increment;
}
\end{lstlisting}

\begin{myitemize}
\item Pętla \lstinline[style=MyCStyle]{for}.
\end{myitemize}

\begin{lstlisting}[style=MyCStyle,caption=Pętla for - przykład]
for (i = initial_i; i <= i_max; i = i + i_increment)
{
...block of statements...
}
\end{lstlisting}


\subsubsection{Konstrukcje warunkowe}

\subsubsection{Operatory relacji}

\begin{table}[h!]
\centering
\caption{Operatory relacji}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.15\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Typ} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{<}} & smaller than \\ \hline
\mbox{\lstinline[style=MyBashStyle]{<=}} & smaller than or equal to \\ \hline
\mbox{\lstinline[style=MyBashStyle]{==}} & equal to \\ \hline
\mbox{\lstinline[style=MyBashStyle]{!=}} & not equal to \\ \hline
\mbox{\lstinline[style=MyBashStyle]{>=}} & greater than or equal to \\ \hline
\mbox{\lstinline[style=MyBashStyle]{>}} & greater than \\ \hline
\end{tabular}
\label{tab:operatoryrelacji}
\end{table}



\subsubsection{Operatory logiczne}

\begin{table}[h!]
\centering
\caption{Operatory logiczne}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.15\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Typ} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{&&}} & and \\ \hline
\mbox{\lstinline[style=MyBashStyle]{||}} & or \\ \hline
\mbox{\lstinline[style=MyBashStyle]{!}} & not \\ \hline
\end{tabular}
\label{tab:operatorylogiczne}
\end{table}

\subsubsection{Wskaźniki}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{img/pointer}
\caption{Idea wskaźnika}
\label{fig:wskaznik}
\end{figure}


\subsubsection{Tablice}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{img/tablica}
\caption{Tablica a~wskaźnika}
\label{fig:tablica}
\end{figure}

\subsubsection{Funkcje}

\subsubsection{Przekazywanie argumentów z wiersza poleceń}

\subsubsection{Operacje I/O (wejścia/wyjścia)}

\subsubsection{Operacje I/O na plikach}

\begin{table}[h!]
\centering
\caption{Operacje na plikach}
\setlength{\arrayrulewidth}{1pt}
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ |p{0.15\textwidth}|p{0.4\textwidth}|}
\hline \rowcolor{gray}
\textbf{Typ} & \textbf{Opis} \\ \hline
\mbox{\lstinline[style=MyBashStyle]{r}} & czytanie z~pliku \\ \hline
\mbox{\lstinline[style=MyBashStyle]{w}} & pisanie do pliku \\ \hline
\mbox{\lstinline[style=MyBashStyle]{a}} & dodanie zawartości do pliku \\ \hline
\end{tabular}
\label{tab:operacjenaplikach}
\end{table}



\subsection{Ćwiczenia}


%\lstinline[style=MyBashStyle]{}
%\begin{lstlisting}[style=MyBashStyle,caption=Rozbudowany plik Makefile]
%\end{lstlisting}

\begin{myenumerate}
\item Zmodyfikować program obliczający tablicę funkcji \lstinline[style=MyBashStyle]{sinus}, tak, aby zawierał instrukcję sterującą \lstinline[style=MyBashStyle]{for}. Utworzyć funkcję \lstinline[style=MyBashStyle]{sinus} i przenieść jej kod do oddzielnego pliku źródłowego \lstinline[style=MyBashStyle]{sinus.c}. Dołączyć plik nagłówkowy \lstinline[style=MyBashStyle]{sinus.h} z~deklaracją funkcji. Napisać odpowiedni skrypt \lstinline[style=MyBashStyle]{Makefile}. Wyniki zapisać do pliku \lstinline[style=MyBashStyle]{sinus.dat}.
\item Napisz funkcję sprawdzającą ile par liczb całkowitych z przedziału \lstinline[style=MyBashStyle]{<a,b>} jest zawartych w~kole o~średnicy \lstinline[style=MyBashStyle]{8}. ($x^2+y^2\leq 8$). Wartości \lstinline[style=MyBashStyle]{a} i~\lstinline[style=MyBashStyle]{b} powinny być zadawane z klawiatury i przekazywane jako parametry funkcji.
\item Napisać bibliotekę operacji wektorowych, wykorzystując struktury. Zdefiniować wektor jako strukturę:

\begin{lstlisting}[style=MyCStyle]
struct Wektor
{
	double x, y, z;
};
\end{lstlisting}

Biblioteka operacji powinna pozwalać na dodawanie, odejmowanie, mnożenie przez liczbę wektora, liczenie iloczynów skalarnych i~wektorowych. Uzupełnić program  o odpowiednie funkcje testowe.
\item Uzupełnić poprzedni program o operacje transformacji wektorów z układu do układu. Napisać funkcje odpowiadające za elementarne obroty wokół osi \lstinline[style=MyBashStyle]{x}, \lstinline[style=MyBashStyle]{y}, \lstinline[style=MyBashStyle]{z}.
\end{myenumerate}




\cleardoublepage
